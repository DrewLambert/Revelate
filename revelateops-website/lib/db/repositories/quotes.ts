import { Prisma } from '@prisma/client';
import { prisma } from '../prisma';
import { logger } from '@/lib/monitoring/logger';
import { createLogContext } from '@/lib/monitoring/log-utils';

/**
 * Quote Repository
 *
 * Handles saving and retrieving quotes generated by users.
 * Includes quote history, PDF URLs, and package associations.
 */

export type Quote = Prisma.QuoteGetPayload<{}>;
export type QuoteWithPackage = Prisma.QuoteGetPayload<{
  include: { package: true };
}>;

export interface CreateQuoteInput {
  // User information
  firstName?: string;
  lastName?: string;
  userEmail?: string;
  phone?: string;
  companyName?: string;
  title?: string;
  comments?: string;
  // Package and services
  packageId?: string;
  scopingInputs?: Record<string, unknown>;
  selectedServices?: string[];
  // Calculated values
  calculatedPrice?: number;
  calculatedTimelineWeeks?: number;
  // Output
  pdfUrl?: string;
  status?: 'draft' | 'sent' | 'accepted';
}

export interface UpdateQuoteInput {
  // User information
  firstName?: string;
  lastName?: string;
  userEmail?: string;
  phone?: string;
  companyName?: string;
  title?: string;
  comments?: string;
  // Package and services
  packageId?: string;
  scopingInputs?: Record<string, unknown>;
  selectedServices?: string[];
  // Calculated values
  calculatedPrice?: number;
  calculatedTimelineWeeks?: number;
  // Output
  pdfUrl?: string;
  status?: 'draft' | 'sent' | 'accepted';
}

/**
 * Create a new quote
 */
export async function createQuote(data: CreateQuoteInput): Promise<Quote> {
  const startTime = performance.now();

  try {
    const quote = await prisma.quote.create({
      data: {
        // User information
        firstName: data.firstName,
        lastName: data.lastName,
        userEmail: data.userEmail,
        phone: data.phone,
        companyName: data.companyName,
        title: data.title,
        comments: data.comments,
        // Package and services
        packageId: data.packageId,
        scopingInputs: data.scopingInputs as Prisma.InputJsonValue | undefined,
        selectedServices: data.selectedServices as Prisma.InputJsonValue,
        // Calculated values
        calculatedPrice: data.calculatedPrice,
        calculatedTimelineWeeks: data.calculatedTimelineWeeks,
        // Output
        pdfUrl: data.pdfUrl,
        status: data.status ?? 'draft',
      },
    });

    logger.info(
      createLogContext({
        action: 'db_query_executed',
        query: 'createQuote',
        quote_id: quote.id,
        user_email: data.userEmail,
        company_name: data.companyName,
        package_id: data.packageId,
        calculated_price: data.calculatedPrice,
        status: quote.status,
        duration_ms: performance.now() - startTime,
      }),
      'Quote created'
    );

    return quote;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'createQuote',
        user_email: data.userEmail,
        package_id: data.packageId,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to create quote'
    );
    throw error;
  }
}

/**
 * Get quote by ID
 */
export async function getQuoteById(id: string): Promise<Quote | null> {
  const startTime = performance.now();

  try {
    const quote = await prisma.quote.findUnique({
      where: { id },
    });

    logger.debug(
      createLogContext({
        action: 'db_query_executed',
        query: 'getQuoteById',
        quote_id: id,
        found: !!quote,
        duration_ms: performance.now() - startTime,
      }),
      quote ? 'Quote retrieved' : 'Quote not found'
    );

    return quote;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'getQuoteById',
        quote_id: id,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to get quote by ID'
    );
    throw error;
  }
}

/**
 * Get quote with package details
 */
export async function getQuoteWithPackage(id: string): Promise<QuoteWithPackage | null> {
  const startTime = performance.now();

  try {
    const quote = await prisma.quote.findUnique({
      where: { id },
      include: {
        package: true,
      },
    });

    logger.debug(
      createLogContext({
        action: 'db_query_executed',
        query: 'getQuoteWithPackage',
        quote_id: id,
        found: !!quote,
        has_package: !!quote?.package,
        duration_ms: performance.now() - startTime,
      }),
      quote ? 'Quote with package retrieved' : 'Quote not found'
    );

    return quote;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'getQuoteWithPackage',
        quote_id: id,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to get quote with package'
    );
    throw error;
  }
}

/**
 * Get quotes by email
 */
export async function getQuotesByEmail(email: string, limit = 50): Promise<Quote[]> {
  const startTime = performance.now();

  try {
    const quotes = await prisma.quote.findMany({
      where: { userEmail: email },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });

    logger.debug(
      createLogContext({
        action: 'db_query_executed',
        query: 'getQuotesByEmail',
        user_email: email,
        quote_count: quotes.length,
        duration_ms: performance.now() - startTime,
      }),
      `Retrieved ${quotes.length} quotes for email`
    );

    return quotes;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'getQuotesByEmail',
        user_email: email,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to get quotes by email'
    );
    throw error;
  }
}

/**
 * Get quotes by company name
 */
export async function getQuotesByCompany(companyName: string, limit = 50): Promise<Quote[]> {
  const startTime = performance.now();

  try {
    const quotes = await prisma.quote.findMany({
      where: { companyName },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });

    logger.debug(
      createLogContext({
        action: 'db_query_executed',
        query: 'getQuotesByCompany',
        company_name: companyName,
        quote_count: quotes.length,
        duration_ms: performance.now() - startTime,
      }),
      `Retrieved ${quotes.length} quotes for company`
    );

    return quotes;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'getQuotesByCompany',
        company_name: companyName,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to get quotes by company'
    );
    throw error;
  }
}

/**
 * Get quotes by status
 */
export async function getQuotesByStatus(
  status: 'draft' | 'sent' | 'accepted',
  limit = 100
): Promise<Quote[]> {
  const startTime = performance.now();

  try {
    const quotes = await prisma.quote.findMany({
      where: { status },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });

    logger.debug(
      createLogContext({
        action: 'db_query_executed',
        query: 'getQuotesByStatus',
        status,
        quote_count: quotes.length,
        duration_ms: performance.now() - startTime,
      }),
      `Retrieved ${quotes.length} quotes with status: ${status}`
    );

    return quotes;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'getQuotesByStatus',
        status,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to get quotes by status'
    );
    throw error;
  }
}

/**
 * Get recent quotes
 */
export async function getRecentQuotes(limit = 50): Promise<QuoteWithPackage[]> {
  const startTime = performance.now();

  try {
    const quotes = await prisma.quote.findMany({
      include: {
        package: true,
      },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });

    logger.debug(
      createLogContext({
        action: 'db_query_executed',
        query: 'getRecentQuotes',
        quote_count: quotes.length,
        duration_ms: performance.now() - startTime,
      }),
      `Retrieved ${quotes.length} recent quotes`
    );

    return quotes;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'getRecentQuotes',
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to get recent quotes'
    );
    throw error;
  }
}

/**
 * Update a quote
 */
export async function updateQuote(id: string, data: UpdateQuoteInput): Promise<Quote> {
  const startTime = performance.now();

  try {
    const quote = await prisma.quote.update({
      where: { id },
      data: {
        // User information
        ...(data.firstName !== undefined && { firstName: data.firstName }),
        ...(data.lastName !== undefined && { lastName: data.lastName }),
        ...(data.userEmail !== undefined && { userEmail: data.userEmail }),
        ...(data.phone !== undefined && { phone: data.phone }),
        ...(data.companyName !== undefined && { companyName: data.companyName }),
        ...(data.title !== undefined && { title: data.title }),
        ...(data.comments !== undefined && { comments: data.comments }),
        // Package and services
        ...(data.packageId !== undefined && { packageId: data.packageId }),
        ...(data.scopingInputs !== undefined && { scopingInputs: data.scopingInputs }),
        ...(data.selectedServices !== undefined && { selectedServices: data.selectedServices }),
        // Calculated values
        ...(data.calculatedPrice !== undefined && { calculatedPrice: data.calculatedPrice }),
        ...(data.calculatedTimelineWeeks !== undefined && {
          calculatedTimelineWeeks: data.calculatedTimelineWeeks,
        }),
        // Output
        ...(data.pdfUrl !== undefined && { pdfUrl: data.pdfUrl }),
        ...(data.status !== undefined && { status: data.status }),
      },
    });

    logger.info(
      createLogContext({
        action: 'db_query_executed',
        query: 'updateQuote',
        quote_id: id,
        status: quote.status,
        duration_ms: performance.now() - startTime,
      }),
      'Quote updated'
    );

    return quote;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'updateQuote',
        quote_id: id,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to update quote'
    );
    throw error;
  }
}

/**
 * Mark quote as sent
 */
export async function markQuoteAsSent(id: string, pdfUrl?: string): Promise<Quote> {
  return updateQuote(id, {
    status: 'sent',
    ...(pdfUrl && { pdfUrl }),
  });
}

/**
 * Mark quote as accepted
 */
export async function markQuoteAsAccepted(id: string): Promise<Quote> {
  return updateQuote(id, {
    status: 'accepted',
  });
}

/**
 * Delete a quote
 */
export async function deleteQuote(id: string): Promise<void> {
  const startTime = performance.now();

  try {
    await prisma.quote.delete({
      where: { id },
    });

    logger.info(
      createLogContext({
        action: 'db_query_executed',
        query: 'deleteQuote',
        quote_id: id,
        duration_ms: performance.now() - startTime,
      }),
      'Quote deleted'
    );
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'deleteQuote',
        quote_id: id,
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to delete quote'
    );
    throw error;
  }
}

/**
 * Get quote statistics
 */
export async function getQuoteStatistics(): Promise<{
  total: number;
  draft: number;
  sent: number;
  accepted: number;
  averagePrice: number;
}> {
  const startTime = performance.now();

  try {
    const [total, draft, sent, accepted, avgResult] = await Promise.all([
      prisma.quote.count(),
      prisma.quote.count({ where: { status: 'draft' } }),
      prisma.quote.count({ where: { status: 'sent' } }),
      prisma.quote.count({ where: { status: 'accepted' } }),
      prisma.quote.aggregate({
        _avg: {
          calculatedPrice: true,
        },
      }),
    ]);

    const stats = {
      total,
      draft,
      sent,
      accepted,
      averagePrice: Number(avgResult._avg.calculatedPrice ?? 0),
    };

    logger.debug(
      createLogContext({
        action: 'db_query_executed',
        query: 'getQuoteStatistics',
        stats,
        duration_ms: performance.now() - startTime,
      }),
      'Quote statistics retrieved'
    );

    return stats;
  } catch (error) {
    logger.error(
      createLogContext({
        action: 'db_query_failed',
        query: 'getQuoteStatistics',
        error,
        duration_ms: performance.now() - startTime,
      }),
      'Failed to get quote statistics'
    );
    throw error;
  }
}
